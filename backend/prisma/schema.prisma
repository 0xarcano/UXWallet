generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ── Enums ───────────────────────────────────────────────────────────────────

enum SessionStatus {
  OPEN
  CLOSING
  CLOSED
  DISPUTED
}

enum TransactionType {
  STATE_UPDATE
  DEPOSIT
  WITHDRAWAL
  INTENT_FULFILLMENT
}

enum SessionKeyStatus {
  ACTIVE
  EXPIRED
  REVOKED
}

enum FulfillmentSource {
  POOL
  LIFI
}

enum IntentStatus {
  PENDING
  FULFILLED
  SETTLED
  FAILED
}

enum WithdrawalStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

// ── Models ──────────────────────────────────────────────────────────────────

/// Nitrolite state channel session metadata (ERC-7824).
model Session {
  id            String        @id @default(uuid())
  channelId     String        @unique
  participantA  String        // User address (lower-cased)
  participantB  String        // Solver / ClearNode address
  chainId       Int
  status        SessionStatus @default(OPEN)
  latestState   Json?         // Latest signed Nitrolite state for recovery
  latestNonce   Int           @default(0)
  totalLocked   String        @default("0") // BigInt as string
  appSessionId  String?       // Nitrolite app_session_id

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  transactions Transaction[]

  @@index([participantA])
  @@index([status])
  @@map("sessions")
}

/// History of off-chain state transitions for audit and recovery.
model Transaction {
  id        String          @id @default(uuid())
  sessionId String
  session   Session         @relation(fields: [sessionId], references: [id])
  nonce     Int
  stateData Json
  signature String
  type      TransactionType

  createdAt DateTime @default(now())

  @@index([sessionId])
  @@map("transactions")
}

/// Persistent Session Keys (EIP-712 delegations) with permissions.
model SessionKey {
  id             String           @id @default(uuid())
  userAddress    String           // Owner wallet (lower-cased)
  sessionKeyAddr String           // Session key address
  application    String
  scope          String
  allowances     Json             // Array<{ asset: string; amount: string }>
  expiresAt      DateTime
  revokedAt      DateTime?
  status         SessionKeyStatus @default(ACTIVE)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userAddress, sessionKeyAddr])
  @@index([userAddress])
  @@index([status])
  @@map("session_keys")
}

/// Real-time tracking of physical assets across supported chains.
model VaultInventory {
  id      String   @id @default(uuid())
  chainId Int
  asset   String
  amount  String   @default("0") // BigInt as string

  updatedAt DateTime @updatedAt

  @@unique([chainId, asset])
  @@map("vault_inventory")
}

/// Records of intent fulfillments and reward allocation.
model IntentLog {
  id             String            @id @default(uuid())
  intentId       String            @unique
  sourceChainId  Int
  targetChainId  Int
  asset          String
  amount         String
  intentUserAddr String
  fulfilledFrom  FulfillmentSource
  solverReward   String            @default("0")
  userReward     String            @default("0")
  treasuryReward String            @default("0")
  status         IntentStatus      @default(PENDING)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  yieldLogs YieldLog[]

  @@index([intentUserAddr])
  @@index([status])
  @@map("intent_logs")
}

/// Pro-rata profit distribution records (solver → users).
model YieldLog {
  id          String   @id @default(uuid())
  userAddress String
  intentLogId String
  intentLog   IntentLog @relation(fields: [intentLogId], references: [id])
  amount      String   // BigInt as string
  asset       String

  distributedAt DateTime @default(now())

  @@index([userAddress])
  @@map("yield_logs")
}

/// Virtual Ledger: aggregated unified balances per user per asset.
model UserBalance {
  id          String   @id @default(uuid())
  userAddress String
  asset       String
  balance     String   @default("0") // BigInt as string
  chainId     Int?     // null = unified across chains

  updatedAt DateTime @updatedAt

  @@unique([userAddress, asset, chainId])
  @@index([userAddress])
  @@map("user_balances")
}

/// Track pending withdrawals.
model WithdrawalRequest {
  id          String           @id @default(uuid())
  userAddress String
  asset       String
  amount      String
  chainId     Int
  status      WithdrawalStatus @default(PENDING)
  txHash      String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userAddress])
  @@index([status])
  @@map("withdrawal_requests")
}
